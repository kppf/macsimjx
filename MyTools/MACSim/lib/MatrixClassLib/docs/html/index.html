<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MatrixClassLib: The MatrixClass Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>The MatrixClass Library </h1>
<p>
<h2><a class="anchor" name="intro">
Introduction</a></h2>
This class library is designed to make use of matrices and thier associated functions using the C++ programming enviromnent. It is designed to be as flexible as possible in both implementation and usage.<h2><a class="anchor" name="implementation">
Implementation</a></h2>
The matrix classes and thier derivatives come in three main types:<p>
<ul>
<li><b>Stand-alone</b> (e.g. <em><a class="el" href="class_matrix.html">Matrix</a></em>, <em><a class="el" href="class_square_matrix.html">SquareMatrix</a></em>, <em><a class="el" href="class_row_vector.html">RowVector</a></em> ...) </li>
<li><b>Alias</b> (e.g. <em><a class="el" href="class_matrix_alias.html">MatrixAlias</a></em>, <em>SquareMartixAlias</em>, <em><a class="el" href="class_row_vector_alias.html">RowVectorAlias</a></em> ...) </li>
<li><b>Constant alias</b> (e.g. <em><a class="el" href="class_matrix_alias_constant.html">MatrixAliasConstant</a></em>, <em>SquareMartixAliasConstant</em>, <em><a class="el" href="class_row_vector_alias_constant.html">RowVectorAliasConstant</a></em> ...)</li>
</ul>
<h3><a class="anchor" name="implementation_standalone">
Stand-Alone Classes</a></h3>
The stand-alone classes allocate and free thier own memory. They can be instantiated in many ways:<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_matrix.html">Matrix</a> A(2, 2);                 <span class="comment">// 2x2 matrix</span>
    <a class="code" href="class_row_vector.html">RowVector</a> x(4);                 <span class="comment">// 4 element row vector</span>
    <a class="code" href="class_column_vector.html">ColumnVector</a> y(ptr_to_data, 5); <span class="comment">// 5 element column vector initiated with the values in an array</span>
    <a class="code" href="class_matrix.html">Matrix</a> B(A);                    <span class="comment">// New matrix the same size as A, and initiated with the same values</span>
    <a class="code" href="class_matrix.html">Matrix</a> C = A;                   <span class="comment">// New matrix the same size as A, and initiated with the same values</span>
</pre></div><h3><a class="anchor" name="implementation_alias">
Alias Classes</a></h3>
The alias classes can be used to mask or alias another matrix object. This can be useful if you wanted to reference a matrix in a different way, but it can be particularly useful if you already have some data (say in an array), and you want to implement the functionality of the matrix class on that data. For example:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> foo(<span class="keywordtype">double</span> * data, <span class="keywordtype">int</span> size)
    {
        <a class="code" href="class_column_vector_alias.html">ColumnVectorAlias</a> cva(data, size); <span class="comment">// Use the data pointer to act as the storage for the new vector</span>
   
        <span class="comment">// operations on cva...</span>
    }
</pre></div><p>
Remember that you will be allocating your own memory for alias classes. In the above example the <code>data</code> pointer must point to at least <code>size*sizeof(double)</code> bytes of allocated memory.<h3><a class="anchor" name="implementation_constantalias">
Constant Alias Classes</a></h3>
In the situation where you are provided with read only data the constant alias class can be used to provive read only functionality. For example:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> foo(<span class="keyword">const</span> <span class="keywordtype">double</span> * data, <span class="keywordtype">int</span> size)
    {
        <a class="code" href="class_row_vector_alias_constant.html">RowVectorAliasConstant</a> rvac(data, size); <span class="comment">// Use the data pointer to act as read only storage for the new vector</span>
   
        <span class="comment">// read operations on rvac...</span>
    }
</pre></div><h2><a class="anchor" name="usage">
Usage</a></h2>
The matrix class library has been designed to be as intuative to use as possible. The matrix classes, and thier derived classes have certain operations available to them. Operatons are inherited or overridden in derived classes (whichever make most sense), so an operation like <code>transpose()</code> which is available in the <em><a class="el" href="class_matrix.html">Matrix</a></em> class will also be available in its derived class <em><a class="el" href="class_square_matrix.html">SquareMatrix</a></em>. However, a function like <code>inverse()</code> will be available to the <em><a class="el" href="class_square_matrix.html">SquareMatrix</a></em> class, but not to the ordinary <em><a class="el" href="class_matrix.html">Matrix</a></em> class.<p>
To use an operator for a matrix, just call the associated function: <div class="fragment"><pre class="fragment">       <a class="code" href="class_matrix.html">Matrix</a> A(3,3);
       <a class="code" href="class_matrix.html">Matrix</a> B(3,3);
   
       A.rand();            <span class="comment">// Randomise the values of A</span>
   
       B = A.transpose();   <span class="comment">// B becomes the transposed matrix of A</span>
</pre></div><p>
Although the matrix operations look to be member functions of the <em><a class="el" href="class_matrix.html">Matrix</a></em> class, they are in fact member <em>objects</em>. They are a special kind of object where each object has has its <code>operator()</code> method overloaded. These special member objects are called "Matrix Operators", and they all inherit from just two base classes: <a class="el" href="class_matrix_read_operator.html">MatrixReadOperator</a> and <a class="el" href="class_matrix_write_operator.html">MatrixWriteOperator</a>. The classes derived from <a class="el" href="class_matrix_read_operator.html">MatrixReadOperator</a> provide the read functions for the <em><a class="el" href="class_matrix.html">Matrix</a></em> classes, and (you've guessed it!) the <a class="el" href="class_matrix_write_operator.html">MatrixWriteOperator</a> classes provide the write functions.<p>
Further derived classes, for example <em><a class="el" href="class_square_matrix.html">SquareMatrix</a></em>, inherit the <a class="el" href="class_matrix.html">Matrix</a> operations from <a class="el" href="class_matrix.html">Matrix</a>, but also include their own set of operator classes derived from <em><a class="el" href="class_square_matrix_read_operator.html">SquareMatrixReadOperator</a></em> and <em><a class="el" href="class_square_matrix_write_operator.html">SquareMatrixWriteOperator</a></em>. Both of these inherit from <a class="el" href="class_matrix_read_operator.html">MatrixReadOperator</a> and <a class="el" href="class_matrix_write_operator.html">MatrixWriteOperator</a> respectively.<p>
Obviously the AliasConstant classes only contain read operators, while the other classes contain both read and write operators.<p>
For an exmaple, we can look at using a <a class="el" href="class_matrix.html">Matrix</a> class, and a more specific <a class="el" href="class_square_matrix.html">SquareMatrix</a> class. The <a class="el" href="class_square_matrix.html">SquareMatrix</a> class contains both the <a class="el" href="class_matrix.html">Matrix</a> read and write operators, and also the <a class="el" href="class_square_matrix.html">SquareMatrix</a> read and write operatiors.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_matrix.html">Matrix</a> m(10,5);                <span class="comment">// 10x5 matrix</span>
    <a class="code" href="class_square_matrix.html">SquareMatrix</a> sm(5);            <span class="comment">// 5x5 square matrix</span>
   
    m.set(1.0);                    <span class="comment">// make all elements in m equal 1.0</span>
    m = m.multiply(5.34);          <span class="comment">// multiply all elements in m by 5.34 and assign that back to m</span>
    sm = sm.inverse();             <span class="comment">// make sm equal to its own inverse</span>
    sm = m.inverse();              <span class="comment">// ERROR! m is not a square matrix</span>
</pre></div><h3><a class="anchor" name="usage_standardoperators">
Standard Operators</a></h3>
There are many standard operators that have been overloaded to allow for a more readable code when using the matrix class library. These operators include:<p>
<ul>
<li><b>Round brackets () </b> - for accessing matrix elements </li>
<li><b>Arithmetic operators +, -, *, / </b> - for performing aritthmetic operations with matricies </li>
<li><b>Assignment operator= </b> - for assigning one matrix's values (and size) to another</li>
</ul>
Other operators may be overloaded for more specific (derived) matrix types.<p>
Example:<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Implementing the state-space formula:</span>
    <span class="comment">//</span>
    <span class="comment">//     dx = Ax + Bu</span>
    <span class="comment">//</span>
    <a class="code" href="class_column_vector.html">ColumnVector</a> stateEquation(<a class="code" href="class_column_vector.html">ColumnVector</a> x, <a class="code" href="class_column_vector.html">ColumnVector</a> u)
    {
        <a class="code" href="class_matrix.html">Matrix</a> A(3,3);            <span class="comment">// A matrix</span>
        <a class="code" href="class_matrix.html">Matrix</a> B(3,2);            <span class="comment">// B matrix</span>
        <a class="code" href="class_column_vector.html">ColumnVector</a> dx(3);       <span class="comment">// state derivative vector</span>
   
        <span class="comment">// Create A &amp; B matrices</span>
        A(0,0) = 5; A(0,1) = 17; A(0,2) = 0.034;
        A(1,0) = 2.4;  <span class="comment">// etc...</span>
   
        dx = (A * x) + (B * u);   <span class="comment">// Perform state equation</span>
   
        <span class="keywordflow">return</span> dx;                <span class="comment">// Return state vector</span>
    }
</pre></div><h3><a class="anchor" name="usage_morestandardoperators">
More on Standard Operators</a></h3>
To give a little more insight to how the standard operators work it should be explained that they do no more than simply call the relevant <a class="el" href="class_matrix.html">Matrix</a> Operator for the matrix to which they belong. Because of this, there are many <a class="el" href="class_matrix.html">Matrix</a> Operators that belong to matrix classes that the user might otherwise never know existed. For every Standard Operator there will be a specific <a class="el" href="class_matrix.html">Matrix</a> operator that is called, Operators like:<p>
<ul>
<li><code>multiply(operand)</code> - Multiplies the matrix (or derivative) by the operand. </li>
<li><code>add(oparand)</code> - Adds the matrix (or derivative) by the operand. </li>
<li><code>negative()</code> - Performs a unary minus on the matrix (or derivative). </li>
<li><code>equals(operand)</code> - Makes the matrix (or derivative) equal to its operand. </li>
<li><code>element(index)</code> - Retrives the indexed element of the matrix.</li>
</ul>
These operators are called inline whenever the relevant Standard Operator is called. This means that the following code:<p>
<div class="fragment"><pre class="fragment">    dx = (A * x) + (B * u);   <span class="comment">// Perform state equation</span>
</pre></div><p>
Could equally have been written: <div class="fragment"><pre class="fragment">    dx.equals(A.multiply(x).add(B.multiply(u)));   <span class="comment">// Perform state equation</span>
</pre></div><p>
From that, hopefully you can see the benefits of using Standard Operators!<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><b>DONE</b> Add rest of operators <p>
<b>DONE</b> Add specific resize operators that only take one value for vectors and square matrices. <p>
Create exception class and replace error() functions. <p>
change return type for write operators (to return *this) <p>
Test constructors fully <p>
Test copy constructors fully. <p>
Test assignment operators fully <p>
Test SubMatrix class fully <p>
Test/fix luDecomp and related functons (and cofactor() ) </dd></dl>
<hr size="1"><address style="align: right;"><small>Generated on Sun Sep 4 14:37:19 2005 for MatrixClassLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
