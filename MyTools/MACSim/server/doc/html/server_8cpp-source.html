<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MACSim Server: MACSim/server/src/server.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">MACSim</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">server</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">src</a></div>
<h1>server.cpp</h1><a href="server_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">//----------------------------------------------------------------------------</span>
00002 <span class="comment">// server.cpp</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Project : Multi-Agent Control in a Simulink block</span>
00005 <span class="comment">// File    : Server class implementation</span>
00006 <span class="comment">//</span>
00007 <span class="comment">// Version : 1.0</span>
00008 <span class="comment">// Date    : 9th February 2005</span>
00009 <span class="comment">// Author  : Peter Mendham</span>
00010 <span class="comment">//</span>
00011 <span class="comment">// (c) University of York</span>
00012 <span class="comment">//----------------------------------------------------------------------------</span>
00013 
00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00015 
00016 <span class="preprocessor">#include "../include/server.h"</span>
00017 
00018 <span class="comment">//----------------------------------------------------------------------------</span>
00019 <span class="comment">// Defined pipe timeout time in milliseconds</span>
00020 <span class="comment">//----------------------------------------------------------------------------</span>
00021 
<a name="l00022"></a><a class="code" href="class_server.html#t0">00022</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="class_server.html#t0">Server::PIPE_TIMEOUT</a> = 1000;
00023 
00024 <span class="comment">//----------------------------------------------------------------------------</span>
00025 <span class="comment">// Constructor</span>
00026 <span class="comment">//----------------------------------------------------------------------------</span>
00027 
<a name="l00028"></a><a class="code" href="class_server.html#a0">00028</a> <a class="code" href="class_server.html#a0">Server::Server</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* p_serverName, <span class="keyword">const</span> <span class="keywordtype">char</span>* p_pipeName, <span class="keywordtype">int</span> p_inBuffSize, <span class="keywordtype">int</span> p_outBuffSize)
00029 {
00030         <span class="comment">// Setup strings</span>
00031         <a class="code" href="class_server.html#z4_0">m_serverName</a> = p_serverName;
00032         <a class="code" href="class_server.html#z4_1">m_pipeName</a> = p_pipeName;
00033 
00034         <span class="comment">// Copy buffer sizes</span>
00035         <a class="code" href="class_server.html#z4_2">m_inBuffSize</a> = p_inBuffSize;
00036         <a class="code" href="class_server.html#z4_3">m_outBuffSize</a> = p_outBuffSize;
00037 }
00038 
00039 <span class="comment">//----------------------------------------------------------------------------</span>
00040 <span class="comment">// Destructor</span>
00041 <span class="comment">//----------------------------------------------------------------------------</span>
00042 
<a name="l00043"></a><a class="code" href="class_server.html#a1">00043</a> <a class="code" href="class_server.html#a1">Server::~Server</a>()
00044 {
00045         <span class="comment">// Make sure thread has finished</span>
00046         <a class="code" href="class_thread.html#a3">terminate</a>();
00047 }
00048 
00049 <span class="comment">//----------------------------------------------------------------------------</span>
00050 <span class="comment">// Main function</span>
00051 <span class="comment">//----------------------------------------------------------------------------</span>
00052 
<a name="l00053"></a><a class="code" href="class_server.html#b1">00053</a> <span class="keywordtype">int</span> <a class="code" href="class_server.html#b1">Server::main</a>()
00054 {
00055         HANDLE hPipe, hEvents[2];
00056         DWORD dwWaitReturn, dwTemp;
00057         LPVOID lpvRequest, lpvReply;
00058         DWORD cbWritten, cbRead;
00059         OVERLAPPED gOverlapped;
00060         BOOL fSuccess;
00061 
00062         <span class="comment">// Signal that we have started</span>
00063         SetEvent(m_hSynchroEvent);
00064 
00065         <span class="comment">// Create server pipe</span>
00066         hPipe = CreateNamedPipe(
00067                 <a class="code" href="class_server.html#z4_1">m_pipeName</a>.c_str(),                     <span class="comment">// pipe name</span>
00068                 PIPE_ACCESS_DUPLEX |            <span class="comment">// read/write access</span>
00069                 FILE_FLAG_OVERLAPPED,           <span class="comment">// gOverlapped (asynchronous) mode</span>
00070                 PIPE_TYPE_MESSAGE |             <span class="comment">// message type pipe</span>
00071                 PIPE_READMODE_MESSAGE |         <span class="comment">// message-read mode</span>
00072                 PIPE_WAIT,                      <span class="comment">// blocking mode</span>
00073                 1,                                                      <span class="comment">// max. instances</span>
00074                 <a class="code" href="class_server.html#z4_3">m_outBuffSize</a>,                          <span class="comment">// output buffer size</span>
00075                 <a class="code" href="class_server.html#z4_2">m_inBuffSize</a>,                           <span class="comment">// input buffer size</span>
00076                 <a class="code" href="class_server.html#t0">PIPE_TIMEOUT</a>,                   <span class="comment">// client time-out</span>
00077                 NULL);                          <span class="comment">// no security attribute</span>
00078 
00079         <span class="keywordflow">if</span> (hPipe == INVALID_HANDLE_VALUE)
00080         {
00081                 printf(<span class="stringliteral">"\n\tFatal Error: Unable to create %s pipe (%d)\n"</span>, <a class="code" href="class_server.html#z4_0">m_serverName</a>.c_str(), GetLastError());
00082                 <span class="keywordflow">return</span> 1;
00083         }
00084 
00085         <span class="comment">// Create request and reply buffers</span>
00086         lpvRequest = LocalAlloc(LMEM_FIXED, m_inBuffSize);
00087         <span class="keywordflow">if</span> (lpvRequest == NULL)
00088         {
00089                 printf(<span class="stringliteral">"\n\tFatal Error: Unable to allocate input buffer for %s pipe\n"</span>, <a class="code" href="class_server.html#z4_0">m_serverName</a>.c_str());
00090                 CloseHandle(hPipe);
00091                 <span class="keywordflow">return</span> 2;
00092         }
00093         
00094         lpvReply = LocalAlloc(LMEM_FIXED, m_outBuffSize);
00095         <span class="keywordflow">if</span> (lpvReply == NULL)
00096         {
00097                 printf(<span class="stringliteral">"\n\tFatal Error: Unable to allocate output buffer for %s pipe\n"</span>, <a class="code" href="class_server.html#z4_0">m_serverName</a>.c_str());
00098                 LocalFree(lpvRequest);
00099                 CloseHandle(hPipe);
00100                 <span class="keywordflow">return</span> 3;
00101         }
00102 
00103         <span class="comment">// Copy handle to termination event</span>
00104         hEvents[0] = m_hTerminateEvent;
00105 
00106         <span class="comment">// Setup overlapped structure with required event</span>
00107         ZeroMemory(&amp;gOverlapped, <span class="keyword">sizeof</span>(OVERLAPPED));
00108         hEvents[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
00109         gOverlapped.hEvent = hEvents[1];
00110 
00111         <span class="comment">// Loop until we are requested to terminate</span>
00112         <span class="keywordflow">do</span>
00113         {
00114                 <span class="comment">// Setup pipe connection</span>
00115                 ConnectNamedPipe(hPipe, &amp;gOverlapped);
00116 
00117                 <span class="comment">// Wait for someone to connect to the pipe or for termination</span>
00118                 dwWaitReturn = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
00119 
00120                 <span class="comment">// Check for an error</span>
00121                 <span class="keywordflow">if</span> (dwWaitReturn == WAIT_FAILED)
00122                         <span class="keywordflow">break</span>;
00123 
00124                 <span class="comment">// Check to see if we got here because of the termination event</span>
00125                 <span class="keywordflow">if</span> (dwWaitReturn == WAIT_OBJECT_0 ||
00126                         dwWaitReturn == WAIT_ABANDONED_0)
00127                 {
00128                         <span class="keywordflow">break</span>;
00129                 }
00130 
00131                 <span class="comment">// Make sure we got woken because of pipe</span>
00132                 <span class="keywordflow">if</span> (GetOverlappedResult(hPipe, &amp;gOverlapped, &amp;dwTemp, FALSE) == FALSE)
00133                         <span class="keywordflow">break</span>;
00134 
00135                 <span class="comment">// Loop to read and write whilst pipe is open</span>
00136                 <span class="keywordflow">do</span>
00137                 {
00138                         <span class="comment">// Read client requests from the pipe.</span>
00139                         fSuccess = ReadFile(
00140                                 hPipe,          <span class="comment">// handle to pipe</span>
00141                                 lpvRequest,     <span class="comment">// buffer to receive data</span>
00142                                 m_inBuffSize,   <span class="comment">// size of buffer</span>
00143                                 &amp;cbRead,                <span class="comment">// number of bytes read</span>
00144                                 &amp;gOverlapped);  <span class="comment">// overlapped I/O</span>
00145 
00146                         <span class="comment">// Check for error condition</span>
00147                         <span class="keywordflow">if</span> (!fSuccess &amp;&amp; GetLastError() != ERROR_IO_PENDING)
00148                                 <span class="keywordflow">break</span>;
00149 
00150                         <span class="comment">// Wait for completion of read operation of for termination event</span>
00151                         dwWaitReturn = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
00152 
00153                         <span class="comment">// Check for an error</span>
00154                         <span class="keywordflow">if</span> (dwWaitReturn == WAIT_FAILED)
00155                                 <span class="keywordflow">break</span>;
00156 
00157                         <span class="comment">// Check to see if we got here because of the termination event</span>
00158                         <span class="keywordflow">if</span> (dwWaitReturn == WAIT_OBJECT_0 ||
00159                                 dwWaitReturn == WAIT_ABANDONED_0)
00160                         {
00161                                 <span class="keywordflow">break</span>;
00162                         }
00163 
00164                         <span class="comment">// Make sure we got woken because of read</span>
00165                         <span class="keywordflow">if</span> (GetOverlappedResult(hPipe, &amp;gOverlapped, &amp;dwTemp, FALSE) == FALSE)
00166                                 <span class="keywordflow">break</span>;
00167 
00168                         <span class="comment">// Get response to request</span>
00169                         <a class="code" href="class_server.html#b0">serverFunc</a>(lpvRequest, lpvReply);
00170 
00171                         <span class="comment">// Write the reply to the pipe.</span>
00172                         fSuccess = WriteFile(
00173                                 hPipe,          <span class="comment">// handle to pipe</span>
00174                                 lpvReply,       <span class="comment">// buffer to write from</span>
00175                                 m_outBuffSize,  <span class="comment">// number of bytes to write</span>
00176                                 &amp;cbWritten,     <span class="comment">// number of bytes written</span>
00177                                 NULL);          <span class="comment">// not overlapped I/O</span>
00178 
00179                         <span class="comment">// Check for error condition</span>
00180                         <span class="keywordflow">if</span> (!fSuccess || cbWritten != m_outBuffSize)
00181                                 <span class="keywordflow">break</span>;
00182 
00183                 } <span class="keywordflow">while</span> (WaitForSingleObject(hEvents[0], 0) != WAIT_OBJECT_0);
00184 
00185                 <span class="comment">// Disconnect named pipe at the server end</span>
00186                 fSuccess = DisconnectNamedPipe(hPipe);
00187                 <span class="keywordflow">if</span> (!fSuccess)
00188                 {
00189                         printf(<span class="stringliteral">"\n\tFatal Error: Unable to disconnect %s pipe (%d)\n"</span>, <a class="code" href="class_server.html#z4_0">m_serverName</a>, GetLastError());
00190                         <span class="keywordflow">break</span>;
00191                 }
00192 
00193         } <span class="keywordflow">while</span> (WaitForSingleObject(hEvents[0], 0) != WAIT_OBJECT_0);
00194 
00195         <span class="comment">// Destroy pipe synchronisation event</span>
00196         CloseHandle(hEvents[1]);
00197 
00198         <span class="comment">// Free input and output buffers</span>
00199         LocalFree(lpvRequest);
00200         LocalFree(lpvReply);
00201 
00202         <span class="comment">// Close the pipe.</span>
00203         CloseHandle(hPipe);
00204 
00205         <span class="comment">// Signal that we have finished</span>
00206         SetEvent(m_hSynchroEvent);
00207 
00208         <span class="keywordflow">return</span> 0;
00209 }
00210 
00211 <span class="comment">//----------------------------------------------------------------------------</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Mar 9 15:53:43 2005 for MACSim Server by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
